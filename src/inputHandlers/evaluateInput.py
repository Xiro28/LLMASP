from dataclasses import dataclass
from typeguard import typechecked
from inputHandlers.abstractInputHandler import AbstractInputHandler

from contextlib import suppress
import networkx as nx
import matplotlib.pyplot as plt

@typechecked
@dataclass(frozen=False)
class EvaluateInput(AbstractInputHandler):

    def __post_init__ (self):
        self._AbstractInputHandler__system_prompt: str = f"""You are a Natural Language to Datalog translator. 
                                To translate the input to Datalog, you will be asked a sequence of questions. 
                                The answers are inside the user input provided with 'USER_INPUT: input'.
                                Output predicate is a lowercase string (possibly including underscores).  
                                Terms is a comma-separated list of either double quoted strings or integers. 
                                Be sure to control the number of terms in each answer!
                                A predicate MUST terminate with a period.
                                An answer MUST NOT be answered if it is not present in the user input.
                                Remember these instructions and don't say anything!"""
        self.tree = {}

        super().__post_init__()

    def plot_tree(self, dictionary, root_label="root"):
        """
        Plots a dictionary as a tree using NetworkX and Matplotlib.
        
        Args:
            dictionary (dict): Dictionary to plot as a tree.
            root_label (str): Label for the root node.
        """
        def add_edges(graph, parent, subtree):
            """
            Recursively add edges to the graph from the dictionary.
            """
            if isinstance(subtree, dict):
                for key, value in subtree.items():
                    graph.add_edge(parent, key)
                    add_edges(graph, key, value)
            elif isinstance(subtree, list):
                for item in subtree:
                    graph.add_edge(parent, item)
            else:
                graph.add_edge(parent, subtree)

        # Create a directed graph
        graph = nx.DiGraph()

        print(dictionary)

        # Add edges from the dictionary
        add_edges(graph, root_label, dictionary)

        # Draw the graph
        pos = nx.spring_layout(graph, seed=42)  # Position the nodes
        plt.figure(figsize=(12, 8))
        nx.draw(
            graph, pos, with_labels=True, node_size=3000, 
            node_color="lightblue", font_size=10, font_weight="bold", arrows=False
        )
        plt.title("Tree Representation of a Dictionary")
        plt.show()


    def __pre_input_seasoning__(self, user_input: str) -> list:
        """
            Enhances the given input with additional information from the config file to help with the ASP atom extraction.
            
            Parameters:
                user_input: str: The input to be seasoned.
                
            Returns:
                str: The seasoned input with added information to help the LLM for ASP atom extraction.
        """

        questions = self._AbstractInputHandler__config['preprocessing']
        the_user_input = f"USER_INPUT: {user_input}"
        prompt = []

        for q in questions:

            q_key, q_value = list(q.items())[0]

            if q_key == '_':
                prompt.append(f"""Here is some context that you MUST analyze and remember.
                            {q_value}
                            Remember this context and don't say anything!\n
                            """)
            else:
                prompt.append(q_value)

        return prompt
    
    
    def __natural_to_asp__(self, user_input: str) -> str:
        """
            Convert natural language input to ASP (Answer Set Programming) format.
            
            This method takes a natural language input provided by the user and converts it
            into ASP format using the invoke_llm from the LLMHandler class. It preprocesses
            the input by performing input seasoning to extract the atoms contained into the config file,
            and then filters the ASP atoms from the response generated by the LLMHandler.
            
            Parameters:
                user_input (str): The natural language input provided by the user.
                
            Returns:
                str: The ASP-formatted output generated from the natural language input.
        """

        F = ""

        _class_dict = self.get_classes()
        _list = [list_class for list_class in self.get_classes().items() if "list_" in list_class[0]]
        main_class = [main_class[0] for main_class in self.get_classes().items() if "list_" not in main_class[0]]
        
        i = 0

        primary_atoms_params = {}

        self.tree = {}

        for atom in self.__pre_input_seasoning__(user_input):
            
            if "Here is some context that you MUST analyze and remember." in atom:
                continue

            if primary_class := self.links.isLinked(main_class[i]):
                response =  self._AbstractInputHandler__llm_instance.invoke_llm_constrained(self.user_input, _list[i][1], primary_atoms_params[primary_class])
            else:
                response =  self._AbstractInputHandler__llm_instance.invoke_llm_constrained(self.user_input, _list[i][1], None)

            print(response)
           
            # since the response is a dictionary, we need to extract the content
            # there's just one key in the dictionary, so we can just get the first value
            # which is an array of class instances
            for atoms in response.dict().get(f"list_{main_class[i]}"):
                
                if self.links.isPrimary(main_class[i]):
                    if (main_class[i] not in self.tree.keys()):
                        self.tree[main_class[i]] = {}
                        primary_atoms_params[main_class[i]] = []

                    self.tree[main_class[i]][str(_class_dict[main_class[i]](**atoms))] = {}  

                    primary_atoms_params[main_class[i]].append(atoms[list(atoms.keys())[0]])

                elif primary_class := self.links.isLinked(main_class[i]):
                    for key in self.tree[primary_class].keys():
                        # Check if the key matches the first parameter in the atoms dictionary
                        if list(atoms.values())[0].lower() in key:
                            # Insert the value into the dictionary at the matching key
                            self.tree[primary_class][key] = str(_class_dict[main_class[i]](**atoms))
                else:
                    self.tree[main_class[i]] = atoms[str(_class_dict[main_class[i]](**atoms))]


                F += str(_class_dict[main_class[i]](**atoms))
            
            i += 1

        #Plot the tree
        self.plot_tree(self.tree)

        return F
    

    def run(self, custom_input = "", TRAIN_ON: bool = False) -> str:
        """
            Run the input handler to convert the user input to ASP format.
            
            This method takes user input and converts it to ASP format using the natural_to_asp method.
            It then returns the ASP-formatted output.
                
            Returns:
                str: The ASP-formatted output generated from the user input.
        """
        
        #self.user_input = input(">")#self._AbstractInputHandler__llm_instance.invoke_llm(["Create a short story about a 3 people who deciding where to eat. 4 sentences"], 0.5)
        self.user_input = custom_input
        response = self.__natural_to_asp__(self.user_input)

        #self.f.writelines(f"{self.user_input}\n\n\n")
        #self.f.flush()

        #Disable for now
        if TRAIN_ON and False:
            out: str = input(f"Do you want to salve to rag_doc these results: {self.preds}? (y/n): ")

            if out == "y":
                self.__docs_rag.append({"prompt": user_input, "response": self.preds})
                yaml.dump(self.__docs_rag, open(self.__ragDatabaseFilename, "w"))

        return self.__filter_asp_atoms__(response)
